from datetime import datetime
from flask_mail import Message
import requests

from app import db, mail
from typing import List
from .model import User
from .interface import UserInterface


from app import login_manager


class UserService:
    """Class for CRUD operations for user entity"""
    @staticmethod
    def get_all() -> List[User]:
        """Get all users from db

        Returns:
            List[User]: list of users 
        """
        return User.query.all()
    
    @staticmethod
    def get_super_admins_emails() -> List[str]:
        """Get super admins emails

        Returns:
            List[str]: list of superadmins emails
        """
        super_admins = User.query.filter_by(super_admin=1)
        return [super_admin.email for super_admin in super_admins]
    
    @staticmethod
    def get_all_emails() -> List[str]:
        """Get all emails

        Returns:
            List[str]: list of users emails
        """
        return [user.email for user in User.query.all()]

    @staticmethod
    def get_by_id(id: str) -> User:
        """Get user entity by id

        Args:
            id (str): if the user is logged by email, it's the email address else it's id generated by github

        Returns:
            User
        """
        return User.query.get(id)

    @staticmethod
    def get_by_username(username: str) -> User:
        """Get user entity by username 

        Args:
            username (str): username of github or the string before '@' if the user logged by email

        Returns:
            User
        """
        return User.query.filter_by(username=username).first()

    @staticmethod
    @login_manager.user_loader
    def login_by_id(id: str) -> User:
        """Retreive user object after logging

        Args:
            id (str): user id

        Returns:
            User
        """
        return User.query.get(id)

    @staticmethod
    def update(user: User, user_change_updates: UserInterface) -> User:
        """update user information

        Args:
            user (User): user object
            user_change_updates (UserInterface): dict of changes to apply 

        Returns:
            User: user entity with the updated information
        """
        user.update(user_change_updates)
        db.session.commit()
        return user

    @staticmethod
    def delete_by_id(id: str):
        """delete user from db using id 

        Args:
            id (str): user id 
        """
        user = User.query.filter(User.id == id).first()
        if user:
            db.session.delete(user)
            db.session.commit()

    @staticmethod
    def create(new_attrs: UserInterface) -> User:
        """Create new user in db

        Args:
            new_attrs (UserInterface): user attributes

        Returns:
            User
        """
        new_user = User(**new_attrs)

        db.session.add(new_user)
        db.session.commit()

        return new_user

    @staticmethod
    def change_super_admin(user: User, super_admin: bool):
        """Update the status of super admin

        Args:
            user (User): 
            super_admin (bool): True if we want to add new super_admin else false
        """
        if user:
            user.super_admin = super_admin
            db.session.commit()
            print("<super_admin manager> : superadmin '{}' was {}".format(user.username, "ADDED" if super_admin else "REMOVED"))

class UserAuthService:
    """Class concerns different methods used in the authentication"""
    @staticmethod
    def create_or_update_user(parsed_user_info: dict):
        """Create new user or update user information after logging in

        Args:
            parsed_user_info (dict): dict of different attributes parsed after user social authentication 

        Returns:
            user: user entity created or updated after logging in
        """
        
        user = UserService.login_by_id(parsed_user_info["id"])
        
        if not user:

            new_attrs: UserInterface = {
                "id": parsed_user_info["id"],
                "auth_provider": parsed_user_info["auth_provider"],
                "github_access_token": parsed_user_info["access_token"] if "access_token" in parsed_user_info.keys() else "",
                "username": parsed_user_info["username"],
                "first_name": parsed_user_info["first_name"],
                "family_name": parsed_user_info["family_name"],
                "email": parsed_user_info["email"],
                "not_share_email": False,
                "picture_url": parsed_user_info ["picture_url"],
                "super_admin": False,
                "created_date": datetime.utcnow(),
                "last_seen": datetime.utcnow(),
            }

            user = UserService.create(new_attrs)
        else:
            if  user.auth_provider == "4":
                changes: UserInterface = {
                    "github_access_token": parsed_user_info["access_token"],
                    "picture_url": parsed_user_info["picture_url"],
                }
            else: 
                changes: UserInterface = {
                    "picture_url": parsed_user_info["picture_url"]
                }
            user = UserService.update(user, changes)
            
        return user
                      

    @staticmethod
    def parse_user_information(provider_name: str, user):
        """Parse user information based on the social login provider

        Args:
            provider_name (str): google | github
            user: user object from result of authentication

        Returns:
            result_parsed: dict of different information of the user
        """
        results_parsed = {}

        if provider_name == "github":
            results_parsed["auth_provider"] = "4"
            results_parsed["access_token"] = user.data.get("access_token")
            data = UserAuthService.get_github_user_information(results_parsed["access_token"])
            results_parsed["id"] = data.get("id")
            results_parsed["username"] = data.get("login")
            results_parsed["picture_url"] = data.get("avatar_url")
            results_parsed["email"] = data.get("email")

        elif provider_name == "google":
            results_parsed["auth_provider"] = "3"
            results_parsed["id"] = user.email
            results_parsed["username"] = user.email.split("@")[0]
            results_parsed["email"] = user.email
            results_parsed["first_name"] = user.first_name
            results_parsed["family_name"] = user.last_name
            results_parsed["picture_url"] = user.picture

        return results_parsed
    
    
    @staticmethod
    def get_github_user_information(access_token: str):
        """Get different user information from github

        Args:
            access_token (str): access token generated after logging with github

        Returns:
            data: dict of different information retreived from github 
        """
        url = "https://api.github.com/user"
        headers =  {"Authorization": "bearer " + access_token}
        response = requests.get(url, headers=headers)
        data = response.json()
        return data
    
   
class EmailService:
    """Class contains method to send alert using email"""
    
    @staticmethod
    def send_alert_email(title: str, alert: str):
        """
        Send alert email to superadmins when error happened in the servers of grew, parser, arborator 
        using flask-email library

        Args:
            title (str): email title
            alert (str): the content of the email send to the super admins which is the error message
        """
        super_admins_emails = UserService.get_super_admins_emails()
        
        mail_message = Message(
            title,
            recipients=super_admins_emails
        )

        mail_message.body = alert
        mail.send(mail_message)
            